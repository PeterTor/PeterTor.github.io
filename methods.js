
  const MY_NAME = 'Torben Peters'; // Bold this name
  const methods = [

      
      {
        side: 'left',
        videoSrc: 'assets/videos/rollingdepth.mp4',
        title: 'ðŸ›¹ RollingDepth ðŸ›¹: Video Depth without Video Models',
        titleLink: 'https://rollingdepth.github.io',
        authors: [
          { name: 'Bingxin Ke' }, { name: 'Dominik Narnhofer' }, { name: 'Shengyu Huang' }, { name: 'Lei Ke' }, { name: 'Torben Peters' }, { name: 'Katerina Fragkiadaki' }, { name: 'Anton Obukhov' }, { name: 'Konrad Schindler' }
        ],
           icons: [
      {
        href: "http://arxiv.org/abs/2411.19189",
        iconClass: "ai ai-arxiv ai-lg fa-bounce-hover fa-lg",
        text: "Paper"
      },
               {
      // Your Hugging Face link
      href: "https://huggingface.co/spaces/prs-eth/rollingdepth",
      imageSrc: "assets/images/hf-logo.png",
      text: "Try on Hugging Face"
    },
      {
        href: "https://github.com/prs-eth/rollingdepth",
        iconClass: "fa-brands fa-github fa-bounce-hover fa-lg",
        text: "Code"
      }
    ],

        publishedInfo: 'Conference on Computer Vision and Pattern Recognition (CVPR) 2025'
      },
      {
        side: 'right',
        id: 'paper-gen',
        videoSrc: 'assets/videos/HighResTrailer.mp4',
        title: 'TetraDiffusion: Tetrahedral Diffusion Models for 3D Shape Generation',
        titleLink: 'https://tetradiffusion.github.io/',
        icons: [
      {
        href: "https://arxiv.org/abs/2211.13220",
        iconClass: "ai ai-arxiv ai-lg fa-bounce-hover fa-lg",
        text: "Paper"
      },
      {
        href: "https://github.com/PeterTor/TetraDiffusion",
        iconClass: "fa-brands fa-github fa-bounce-hover fa-lg",
        text: "Code"
      }
      ],
        authors: [
          { name: 'Nikolai Kalischek',sharedAuthorship:true }, { name: 'Torben Peters',sharedAuthorship:true }, { name: 'Jan D Wegner' }, { name: 'Konrad Schindler' }
        ],
        publishedInfo: 'European Conference on Computer Vision (ECCV) 2024'
      },
      
      {
        side: 'left',
        id: 'paper-env',
        imageSrc: 'assets/images/agbd.png',
        title: 'ðŸŒ² AGBD: A Global-scale Biomass Dataset ðŸŒ³',
        titleLink: 'https://huggingface.co/datasets/prs-eth/AGBD',
        authors: [
          { name: 'Ghjulia Sialelli' }, { name: 'Torben Peters' }, { name: 'Jan D Wegner' }, { name: 'Konrad Schindler' }
        ],
        icons: [
      {
        href: "https://arxiv.org/abs/2406.04928",
        iconClass: "ai ai-arxiv ai-lg fa-bounce-hover fa-lg",
        text: "Paper"
      },
               {
      // Your Hugging Face link
      href: "https://huggingface.co/datasets/prs-eth/AGBD",
      imageSrc: "assets/images/hf-logo.png",
      text: "Hugging Face"
    },
      {
        href: "https://github.com/ghjuliasialelli/AGBD",
        iconClass: "fa-brands fa-github fa-bounce-hover fa-lg",
        text: "Code"
      }
    ],
        publishedInfo: 'Conference Paper, ISPRS Annals of the Photogrammetry, 2025'
      },
      
      {
        side: 'right',
        id: 'paper-hum',
        imageSrc: 'https://github.com/prs-eth/ukraine-damage-mapping-tool/raw/main/doc/ukraine_damage_adm3_agg.png',
        title: 'An Open-Source Tool for Mapping War Destruction at Scale in Ukraine using Sentinel-1 Time Series',
        titleLink: 'https://github.com/prs-eth/ukraine-damage-mapping-tool',
        icons: [
      {
        href: "https://arxiv.org/abs/2406.02506",
        iconClass: "ai ai-arxiv ai-lg fa-bounce-hover fa-lg",
        text: "Paper"
      },
               {
      // Your Hugging Face link
      href: "https://olidietrich.users.earthengine.app/view/ukraine-damage-explorer",
      imageSrc: "assets/images/googleearth-engine.png",
      text: "Google Earth"
    },
      {
        href: "https://github.com/prs-eth/ukraine-damage-mapping-tool",
        iconClass: "fa-brands fa-github fa-bounce-hover fa-lg",
        text: "Code"
      }
    ],
        authors: [
          { name: 'Olivier Dietrich' }, { name: 'Torben Peters' }, { name: 'Vivien Sainte Fare Garnot' }, { name: 'Valerie Sticher' }, { name: 'Thao Ton-That Whelan' }, { name: 'Konrad Schindler' }, { name: 'Jan Dirk Wegner' }
        ],
        publishedInfo: 'Nature Communications Earth & Environment'
      },

      {
        side: 'left',
        imageSrc: 'assets/images/forestinventory.jpg',
        title: 'Automated forest inventory: Analysis of high-density airborne LiDAR point clouds with 3D deep learning',
        titleLink: 'https://github.com/prs-eth/ForAINet',
        authors: [
          { name: 'Binbin Xiang' }, { name: 'Maciej Wielgosz' }, { name: 'Theodora Kontogianni' }, { name: 'Torben Peters' }, { name: 'Stefano Puliti' }, { name: 'Rasmus Astrup' }, { name: 'Konrad Schindler' }
        ],
         icons: [
      {
        href: "https://arxiv.org/abs/2312.15084",
        iconClass: "ai ai-arxiv ai-lg fa-bounce-hover fa-lg",
        text: "Paper"
      },

      {
        href: "https://github.com/prs-eth/ForAINet",
        iconClass: "fa-brands fa-github fa-bounce-hover fa-lg",
        text: "Code"
      }
    ],
        publishedInfo: 'Journal Remote Sensing of Environment, 2024'
      },
      
      
      {
        side: 'right',
        imageSrc: 'assets/images/review.jpg',
        title: 'A review of panoptic segmentation for mobile mapping point clouds',
        titleLink: 'https://arxiv.org/abs/2304.13980',
        authors: [
          { name: 'Binbin Xiang' }, { name: 'Yuanwen Yue' }, { name: 'Torben Peters' }, { name: 'Konrad Schindler' }
        ],
        icons: [
      {
        href: "https://arxiv.org/abs/2304.13980",
        iconClass: "ai ai-arxiv ai-lg fa-bounce-hover fa-lg",
        text: "Paper"
      },

      {
        href: "https://github.com/prs-eth/PanopticSegForMobileMappingPointClouds",
        iconClass: "fa-brands fa-github fa-bounce-hover fa-lg",
        text: "Code"
      }
    ],
        publishedInfo: 'ISPRS Journal of Photogrammetry and Remote Sensing, 2023'
      },
      
      {
        side: 'left',
        id: 'paper-3d',
        imageSrc: 'assets/images/MVTeaser.png',
        title: 'Semantic segmentation of mobile mapping point clouds via multi-view label transfer',
        titleLink: 'https://www.sciencedirect.com/science/article/pii/S0924271623001351',
        authors: [
          { name: 'Torben Peters' }, { name: 'Claus Brenner' }, { name: 'Konrad Schindler' }
        ],
        icons: [
      {
        href: "https://www.sciencedirect.com/science/article/pii/S0924271623001351",
        iconClass: "ai ai-arxiv ai-lg fa-bounce-hover fa-lg",
        text: "Paper"
      },
    ],
        publishedInfo: 'ISPRS Journal of Photogrammetry and Remote Sensing, 2023' 
      },
      
      {
        side: 'right',
        imageSrc: 'assets/images/instanceseg.png',
        title: 'Towards accurate instance segmentation in large-scale LiDAR point clouds',
        titleLink: 'https://github.com/prs-eth/PanopticSegForLargeScalePointCloud',
        authors: [
          { name: 'Binbin Xiang' }, { name: 'Torben Peters' }, { name: 'Theodora Kontogianni' }, { name: 'Frawa Vetterli' }, { name: 'Stefano Puliti' }, { name: 'Rasmus Astrup' }, { name: 'Konrad Schindler' }
        ],
        icons: [
      {
        href: " https://arxiv.org/abs/2307.02877",
        iconClass: "ai ai-arxiv ai-lg fa-bounce-hover fa-lg",
        text: "Paper"
      },

      {
        href: "https://github.com/prs-eth/PanopticSegForMobileMappingPointClouds",
        iconClass: "fa-brands fa-github fa-bounce-hover fa-lg",
        text: "Code"
      }
    ],
        publishedInfo: 'Conference Paper, ISPRS Annals of the Photogrammetry, 2023'
      },
      
      {
        side: 'left',
        imageSrc: 'assets/images/biasbed.png',
        title: 'Biasbed-rigorous texture bias evaluation',
        titleLink: 'https://openaccess.thecvf.com/content/CVPR2023/papers/Kalischek_BiasBed_-_Rigorous_Texture_Bias_Evaluation_CVPR_2023_paper.pdf',
        authors: [
          { name: 'Nikolai Kalischek' }, { name: 'Rodrigo Caye Daudt' }, { name: 'Torben Peters' }, { name: 'Reinhard Furrer' }, { name: 'Jan D Wegner' }, { name: 'Konrad Schindler' }
        ], icons: [
      {
        href: "https://arxiv.org/abs/2211.13190",
        iconClass: "ai ai-arxiv ai-lg fa-bounce-hover fa-lg",
        text: "Paper"
      },

      {
        href: "https://github.com/D1noFuzi/BiasBed",
        iconClass: "fa-brands fa-github fa-bounce-hover fa-lg",
        text: "Code"
      }
    ],
        publishedInfo: 'Conference on Computer Vision and Pattern Recognition (CVPR) 2023'
      },
      
      
      {
        side: 'right',
        imageSrc: 'assets/images/shapecompletion.png',
        title: 'Self-Supervised Adversarial Shape Completion',
        titleLink: 'https://isprs-annals.copernicus.org/articles/V-2-2022/143/2022/isprs-annals-V-2-2022-143-2022.pdf',
        authors: [
          { name: 'Torben Peters' }, { name: 'Konrad Schindler' }, { name: 'Claus Brenner' }
        ],
        icons: [
      {
        href: "https://isprs-annals.copernicus.org/articles/V-2-2022/143/2022/isprs-annals-V-2-2022-143-2022.pdf",
        iconClass: "ai ai-arxiv ai-lg fa-bounce-hover fa-lg",
        text: "Paper"
      }

    ],
        publishedInfo: 'Conference Paper, ISPRS Annals of the Photogrammetry, 2022'
      },
      {
        side: 'left',
        videoSrc: 'assets/videos/cgan.mp4',
        title: 'Conditional adversarial networks for multimodal photo-realistic point cloud rendering',
        titleLink: 'https://link.springer.com/article/10.1007/s41064-020-00114-z',
        authors: [
          { name: 'Torben Peters' }, { name: 'Claus Brenner' }
        ],
        icons: [
          {
            href: "https://link.springer.com/article/10.1007/s41064-020-00114-z",
            iconClass: "ai ai-arxiv ai-lg fa-bounce-hover fa-lg",
            text: "Paper"
          },{
            href: "https://www.youtube.com/watch?v=33fBXfaYA7E",
            iconClass: "fa-brands fa-youtube fa-bounce-hover fa-lg",
            text: "YouTube"
          }

        ],
        publishedInfo: 'PFGâ€“Journal of Photogrammetry, Remote Sensing and Geoinformation Science, 2020'
      },
      {
        side: 'right',
        id: 'paper-rob',
        videoSrc: 'assets/videos/robot.mp4',
        imageSrc: "https://github.com/PeterTor/DDPG-Gait/raw/master/robot/real_small.jpg",
        title: 'Deep Reinforcement Learning - a robot learns to walk',
        titleLink: 'https://github.com/PeterTor/DDPG-Gait',
        authors: [
          { name: 'Torben Peters' }
        ],
        icons: [

      {
        href: "https://github.com/PeterTor/DDPG-Gait",
        iconClass: "fa-brands fa-github fa-bounce-hover fa-lg",
        text: "Code"
      }
    ],
        publishedInfo: 'Victor Rizkallah Award for Outstanding Master Thesis'
      }
    

  ];




  function createMethodHTML(method) {
    // Track if at least one author has sharedAuthorship
    let foundSharedAuth = false;

    // Build the author list
    const authorsHTML = method.authors
        .map((author) => {
          let displayName = author.name;

          // Make MY_NAME bold (case-insensitive)
          if (displayName.toLowerCase() === MY_NAME.toLowerCase()) {
            displayName = `<strong>${displayName}</strong>`;
          }

          // Add a star if sharedAuthorship: true
          if (author.sharedAuthorship) {
            foundSharedAuth = true;
            displayName += '*';
          }

          // Link to Google Scholar if available
          if (author.scholarLink) {
            return `<a href="${author.scholarLink}" target="_blank">${displayName}</a>`;
          } else {
            return displayName;
          }
        })
        .join(', ');

    // If any author has sharedAuthorship, show this line below the authors
    const sharedAuthLine = foundSharedAuth
        ? `<p><em>* indicates shared first authorship</em></p>`
        : '';

    // Build the icons list (if any)
    const iconsHTML = Array.isArray(method.icons) && method.icons.length > 0
        ? `
      <div style="text-align: center; margin: 0.5rem 0;">
        <ul style="list-style: none; margin: 0; padding: 0; display: inline-flex; gap: 1rem;">
          ${method.icons
            .map((icon) => {
              // If icon has imageSrc, use an <img>; otherwise use <i class="...">
              const iconElement = icon.imageSrc
                  ? `<img src="${icon.imageSrc}" alt="" style="width: 1.4em; height: 1.4em; vertical-align: middle;" />`
                  : `<i class="${icon.iconClass ?? ''}"></i>`;

              return `
                <li>
                  <a class="icon-button" target="_blank" href="${icon.href}">
                    ${iconElement}${icon.text ? `&nbsp;${icon.text}` : ''}
                  </a>
                </li>
              `;
            })
            .join('')}
        </ul>
      </div>
    `
        : '';

    // Media column (video or image)
    let mediaColumn = '';

    if (method.videoSrc && method.imageSrc) {
      // Both video and image -> use smaller gap for stacking
      mediaColumn = `
    <div
      style="
        flex: 1;
        min-width: 300px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        /* Use a very small gap to bring them closer */
        gap: 0.2rem;
        
      "
    >
      <video
        width="240"
        height="240"
        style="object-fit: contain; margin: -40px; padding: 0;"
        autoplay
        muted
        loop
        playsinline
      >
        <source src="${method.videoSrc}" type="video/mp4">
        Your browser does not support the video tag.
      </video>
      <img
        src="${method.imageSrc}"
        alt="${method.title}"
        style="
          width: 240px;
          height: 240px;
          object-fit: contain;
          margin: -40px;
          padding: 0;
        "
      >
    </div>
    `;
    } else if (method.videoSrc) {

      mediaColumn = `
      <div class="method-media"
           style="flex: 1; min-width: 300px; height: 300px; display: flex; align-items: center; justify-content: center;">
        <video width="300" height="300"
               style="object-fit: contain;" autoplay muted loop playsinline>
          <source src="${method.videoSrc}" type="video/mp4">
          Your browser does not support the video tag.
        </video>
      </div>
    `;
    } else if (method.imageSrc) {
      mediaColumn = `
      <div class="method-media"
           style="flex: 1; min-width: 300px; height: 300px; display: flex; align-items: center; justify-content: center;">
        <img src="${method.imageSrc}" alt="${method.title}"
             style="width: 100%; height: 100%; object-fit: contain;">
      </div>
    `;
    }

    // Text column
    const textColumn = `
    <div class="method-description"
         style="flex: 2; height: 300px; display: flex; flex-direction: column; justify-content: center;">
      <h2 style="margin-top: 0;">
        <a href="${method.titleLink}" target="_blank"
           style="text-decoration: none; color: black; font-weight: bold;">
           ${method.title}
        </a>
      </h2>
      <p>${authorsHTML}</p>
      ${sharedAuthLine}
      ${iconsHTML}
      <p><em>${method.publishedInfo}</em></p>
    </div>
  `;

    // Build the outer container, optionally adding an id
    const methodRowId = method.id ? `id="${method.id}"` : '';

    // If side is 'left' => media first, text second
    if (method.side === 'left') {
      return `
      <div ${methodRowId}
           class="method-row"
           style="display: flex; align-items: flex-start; justify-content: space-between; gap: 2rem; margin-bottom: 2rem; height: 300px;">
        ${mediaColumn}
        ${textColumn}
      </div>
    `;
    } else {
      // side === 'right' => text first, media second
      return `
      <div ${methodRowId}
           class="method-row"
           style="display: flex; align-items: flex-start; justify-content: space-between; gap: 2rem; margin-bottom: 2rem; height: 300px;">
        ${textColumn}
        ${mediaColumn}
      </div>
    `;
    }
  }

  document.addEventListener('DOMContentLoaded', function listener() {
    console.log('DOMContentLoaded fired');
    // Ensure listener is removed to prevent duplicate execution
    document.removeEventListener('DOMContentLoaded', listener);

    const container = document.getElementById('methods-container');
    container.innerHTML = ''; // Clear any existing content

    methods.forEach((method) => {
      container.insertAdjacentHTML('beforeend', createMethodHTML(method));
    });
  });

